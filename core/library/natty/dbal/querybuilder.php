<?php

namespace Natty\DBAL;

defined('NATTY') or die;

/**
 * Structued Query Builder
 * @author JigaR Mehta | Greenpill Productions
 */
abstract class QueryBuilder
extends \Natty\StdClass {

    /**
     * WHERE criterions / conditions
     * @var array
     */
    protected $conditions = array();

    /**
     * The connection for which the query is being built
     * @var \Natty\DBAL\Connection
     */
    protected $dbo;

    /**
     * Columns included in the query
     * @var array
     */
    protected $columns = array();

    /**
     * Expressions to operate on
     * @var array
     */
    protected $expressions = array();

    /**
     * Flags for the query. Example, a SELECT query can have a "distinct" flag
     * @var array
     */
    protected $flags = array ();
    
    /**
     * LIMIT clause
     * @var string
     */
    protected $limit;

    /**
     * OFFSET clause
     * @var int 
     */
    protected $offset;

    /**
     * ORDER BY clause
     * @var array
     */
    protected $ordering = array();

    /**
     * A string version of the query generated by the prepared method
     * with parameter placeholders in it
     * @var string
     */
    protected $stringVersion;

    /**
     * Tables for the operation
     * @var array
     */
    protected $tables = array();

    /**
     * Type of the query. Example; SELECT, INSERT, DELETE, UPDATE, etc.
     * @var string
     */
    protected $type = FALSE;

    /**
     * Creates a query builder object.
     * @param string $tablename The primary table of operation
     * @param Base\Connection $dbo [optional] Database connection object
     */
    public function __construct($tablename = NULL, $dbo = NULL) {

        // Determine the connection
        $dbo = $dbo
                ? : \Natty::getDbo();
        $this->dbo = $dbo;

        // Determine and apply primary tablename
        if ($tablename)
            $this->addTable($tablename);
    }

    public function __toString() {
        return $this->render();
    }

    /**
     * Adds a flag to the query.
     * @param string $flag A lowercase string. Example: distinct.
     */
    public function addFlag($flag) {
        $this->flags[$flag] = $flag;
    }
    
    /**
     * Adds a condition to the query. The format and number of parameters 
     * is very important here. The arguments would simply be passed to the
     * QueryCondition constructor.
     * @param string $logic [optional] Type of conjunction to use.
     * One of OR and AND.
     * @param array $condition Expressions as an array with the following
     * ordering of its constituents:<br />
     * <ul>
     *      <li>table.column, (operand), :param</li>
     *      <li>table.column (operand) table.column</li>
     *      <li>table.column (IS|IS NOT) (NULL|TRUE|FALSE)</li>
     *      <li>table.column (IN|NOT IN) Array</li>
     *      <li>table.column (IN|NOT IN) Sub-Query</li>
     *      <li>table.column (LIKE) Pattern</li>
     * </ul>
     * Alternatively, an array of such conditions can also be sent as:<br />
     * $stmt->condition('AND', array (
     *      array ('AND', 'table.column', 'operand', ':param'),
     *      array (
     *          array ('OR', 'table.column', 'operand', ':param'),
     *          array ('OR', 'table.column', 'operand', ':param')
     *      )
     * ));
     * @todo Nested conditions should be easy to specify
     * @return QueryBuilder The query object
     */
    final public function addComplexCondition($logic, $condition = NULL) {

        // If one argument was passed, consider it as an AND
        if (1 == func_num_args()):
            $logic = 'AND';
            $condition = func_get_arg(0);
        endif;

        if ($condition):

            // Verify the condition
            if (!is_array($condition) && !is_string($condition))
                throw new \InvalidArgumentException('Argument 2 expected to be a string or an array');

            // Verify the conjunction
            if (!in_array($logic, array('AND', 'OR')))
                throw new \InvalidArgumentException('Argument 1 expected to be one AND or OR');

            $this->conditions[] = array($logic, $condition);

        endif;

        return $this;
    }
    
    /**
     * Adds simple conditions to the query (no OR clause, no nested query).
     * Example: {id} = :id, {id} > :min_id, , {id} < :max_id, etc.
     * @param string $operand1
     * @param string $operand2
     * @param string $operator [optional] Defaults to equality check (=)
     * @return QueryBuilder The query object
     */
    public function addSimpleCondition($operand1, $operand2, $operator = '=') {
        $condition = array ($operand1, $operator, $operand2);
        $this->conditions[] = array ('AND', $condition);
        return $this;
    }

    /**
     * Prepares and executes the query, returning the PDOStatement Handle
     * @param array $params [optional] Query parameters
     * @return \PDOStatement
     */
    public function execute(array $params = array()) {
        $stmt = $this->prepare();
        sizeof($params) > 0 ? $stmt->execute($params) : $stmt->execute();
        return $stmt;
    }

    /**
     * Returns the connection object associated with the query.
     * @return Base\Connection
     */
    public function getDbo() {
        return $this->dbo;
    }

    /**
     * Prepares the Query with the Database and returns a statement handle
     * @return \PDOStatement|bool The statement handle on success or FALSE.
     */
    public function prepare() {
        $s_query = $this->render();
        return $this->dbo->prepare($s_query);
    }

    /**
     * Adds an expression to the query. Columns used in the expression must be
     * wrapped in {braces} for proper escaping. Not all types of expressions
     * are supported by all database engines, so make sure you use the comon
     * ones only or the ones which are supported by your database engine.
     * @param string $expression
     * @return \Natty\DBAL\QueryBuilder The query object
     */
    public function addExpression($expression) {
        $this->expressions[] = $expression;
        return $this;
    }

    /**
     * Adds multiple columns to the query scope.
     * @param array $columns An array of columns without table alias.
     * @param string $tablename [optional] Alias of the table to which the
     * columns belong.
     * @return \Natty\DBAL\QueryBuilder The query object
     */
    public function addColumns(array $columns, $tablename = NULL) {

        foreach ($columns as $t_column):
            $this->addColumn($t_column, $tablename);
        endforeach;

        return $this;
        
    }

    /**
     * Adds a single column to the query scope.
     * @param string $column Name of the column without table alias. This can
     * also support the wildcard *
     * @param string $tablename [optional] Alias of the table to which the
     * column belongs.
     * @return \Natty\DBAL\QueryBuilder The query object
     */
    public function addColumn($column, $tablename = NULL) {
        if ('*' === $column) {
            $this->expressions[] = '{' . $tablename . '}.*';
        } else {
            $this->columns[] = $tablename ? $tablename . '.' . $column : $column;
        }
        return $this;
    }

    /**
     * Adds a LIMIT clause to the Query; No more than $limit rows would be
     * operated on.
     * @param int $limit
     * @return QueryBuilder The query object
     */
    final public function limit($limit) {
        $this->limit = $limit;
        return $this;
    }

    /**
     * Sets the seek offset from index 0
     * @param int $offset
     * @return QueryBuilder The query object
     */
    final public function offset($offset) {
        $this->offset = $offset;
        return $this;
    }

    /**
     * Adds an ORDER BY clause to the Query
     * @param string $column Field name
     * @param string $order [optional] Sort order: ASC|DESC|RAND
     * @return QueryBuilder The query object
     */
    final public function orderBy($column, $order = NULL) {
        $entry = array($column, $order);
        array_push($this->ordering, $entry);
        return $this;
    }

    public function preview(array $parameters = array ()) {
        
        $preview = $this->render();
        
        // Replace variables
        $search = array ();
        $replace = array ();
        foreach ( $parameters as $param_name => $param_value ):
            $search[] = ':' . $param_name;
            $replace[] = $this->getDbo()->quote($param_value);
        endforeach;
        $preview = str_replace($search, $replace, $preview);
        
        natty_debug($preview);
        
    }

    /**
     * Compiles the Query and returns a string version of it
     * @return string
     */
    public function render() {
        if (!$this->stringVersion)
            $this->stringVersion = $this->dbo->compile($this);
        return $this->stringVersion;
    }

    /**
     * Adds a primary table for the operation
     * @param string $tablename Table name in the format: tablename alias
     * @return QueryBuilder The query object
     */
    public function addTable($tablename) {
        array_push($this->tables, $tablename);
        return $this;
    }

}
